第7章 hello的存储管理
7.1 hello的存储器地址空间
【物理地址】CPU通过地址总线的寻址，找到真实的物理内存对应地址。CPU对内存的访问是通过连接着CPU和北桥芯片的前端总线来完成的。在前端总线上传输的内存地址都是物理内存地址。 
【逻辑地址】程序代码经过编译后出现在汇编程序中地址。逻辑地址由选择符（在实模式下是描述符，在保护模式下是用来选择描述符的选择符）和偏移量（偏移部分）组成。 
【线性地址/虚拟地址】逻辑地址经过“段机制”后转化为线性地址，为“描述符：偏移量”的组合形式。“分页机制”中线性地址作为输入。

 
图7.1 三种地址之间的转换关系

7.2 Intel逻辑地址到线性地址的变换-段式管理
最初8086处理器的寄存器是16位的，为了能够访问更多的地址空间但不改 变寄存器和指令的位宽，所以引入段寄存器。8086共设计了20位宽的地址总线， 通过将段寄存器左移4位加上偏移地址得到20位地址，这个地址就是逻辑地址。将内存分为不同的段，段有段寄存器对应，段寄存器有一个栈、一个代码、两个数据寄存器。 
分段功能在“实模式”和“保护模式”下有所不同。 
实模式下不设防，也就是说逻辑地址=线性地址=实际的物理地址。段寄存器存放真实段基址，同时给出32位地址偏移量，则可以访问真实物理内存。 
保护模式下，线性地址还需要经过分页机制才能够得到物理地址，线性地址也需要逻辑地址通过段机制来得到。段寄存器无法放下32位段基址，所以它们被称作选择符，用于引用段描述符表中的表项来获得描述符。描述符表中的一个 条目描述一个段，构造如下：

 
图7.2 段描述符表中一个条目的构造

Base：基地址，32位线性地址指向段的开始。Limit：段界限，段的大小。DPL： 描述符的特权级0（内核模式）-3（用户模式）。
所有的段描述符被保存在两个表中：全局描述符表GDT和局部描述符表LDT。gdtr寄存器指向GDT表基址。 
段选择符构造如下：

 
图7.3 段描述符的构造

TI：0为GDT，1为LDT。Index指出选择描述符表中的哪个条目，RPL请求 特权级。
所以在保护模式下，分段机制就可以描述为：通过解析段寄存器中的段选择符在段描述符表中根据Index选择目标描述符条目Segment Descriptor，从目标描述符中提取出目标段的基地址Base address，最后加上偏移量offset共同构成线性地址Linear Address。保护模式时分段机制图示如下：
 
图7.4 保护模式下的分段机制

当CPU位于32位模式时，内存4GB，寄存器和指令都可以寻址整个线性地址空间，所以这时候不再需要使用基地址，将基地址设置为0，此时逻辑地址=描述符=线性地址，Intel的文档中将其称为扁平模型（flat model），现代的x86系统内核使用的是基本扁平模型，等价于转换地址时关闭了分段功能。在CPU 64位模式中强制使用扁平的线性空间。逻辑地址与线性地址就合二为一了。

7.3 Hello的线性地址到物理地址的变换-页式管理
线性地址（也就是虚拟地址VA）到物理地址（PA）之间的转换通过分页机制完成。而分页机制是对虚拟地址内存空间进行分页。 
首先Linux系统有自己的虚拟内存系统，其虚拟内存组织形式如图 7.5，Linux将虚拟内存组织成一些段的集合，段之外的虚拟内存不存在因此不需要记录。内核为hello进程维护一个段的任务结构即图中的task_struct，其中条目mm指向一个mm_struct，它描述了虚拟内存的当前状态，pgd指向第一级页表的基地址（结合一个进程一串页表），mmap指向一个vm_area_struct的链表，一个链表条目对应一个段，所以链表相连指出了hello进程虚拟内存中的所有段。

 
图7.5 Linux虚拟内存组织法则

系统将每个段分割为被称为虚拟页（VP）的大小固定的块来作为进行数据传 输的单元，在Linux下每个虚拟页大小为4KB，类似地，物理内存也被分割为物理页（PP/页帧），虚拟内存系统中MMU负责地址翻译，MMU使用存放在物理内存中的被称为页表的数据结构将虚拟页到物理页的映射，即虚拟地址到物理地址的映射。  
如图7.6，不考虑TLB与多级页表，虚拟地址分为虚拟页号VPN和虚拟页偏移量VPO，根据位数限制分析可以确定VPN和VPO分别占多少位是多少。通过页表基址寄存器PTBR+VPN在页表中获得条目PTE，一条PTE中包含有效位、权限信息、物理页号，如果有效位是0+NULL则代表没有在虚拟内存空间中分配该内存，如果是有效位0+非 NULL，则代表在虚拟内存空间中分配了但是没有被缓存到物理内存中，如果有效位是1则代表该内存已经缓存在了物理内存中，可以得到其物理页号PPN，与虚拟页偏移量共同构成物理地址PA。

 
图7.6 基于页表的地址翻译

7.4 TLB与四级页表支持下的VA到PA的变换
在Intel Core i7环境下研究VA到PA的地址翻译问题。前提如下：  
虚拟地址空间48位，物理地址空间52位，页表大小4KB，4级页表。TLB 4路16组相联。CR3指向第一级页表的起始位置（上下文一部分）。  
解析前提条件：由一个页表大小4KB，一个PTE条目8B，共512个条目，使用9位二进制索引，一共4个页表共使用36位二进制索引，所以VPN共36位，因为VA 48位，所以VPO 12位；因为TLB共16组，所以TLBI需4位，因为VPN 36位，所以TLBT 32位。 
 如图 7.7，CPU产生虚拟地址VA，VA传送给MMU，MMU使用前36位VPN作为TLBT（前 32 位）+TLBI（后 4 位）向TLB中匹配，如果命中，则得到PPN（40bit）与VPO（12bit）组合成PA（52bit）。  
如果TLB中没有命中，MMU向页表中查询，CR3确定第一级页表的起始地 址，VPN1（9bit）确定在第一级页表中的偏移量，查询出PTE，如果在物理内存中且权限符合，确定第二级页表的起始地址，以此类推，最终在第四级页表中查询到PPN，与VPO组合成PA，并且向TLB中添加条目。  
如果查询PTE的时候发现不在物理内存中，则引发缺页故障。如果发现权限 不够，则引发段错误。

 
图7.7 TLB与4级页表下Core i7的地址翻译情况

7.5 三级Cache支持下的物理内存访问
前提：只讨论L1 Cache的寻址细节，L2与L3Cache原理相同。L1 Cache是8路64组相联。块大小为64B。  
解析前提条件：因为共64组，所以需要6bit CI进行组寻址，因为共有8路，因为块大小为64B所以需要6bit CO表示数据偏移位置，因为VA共52bit，所以CT共40bit。 
 在上一步中我们已经获得了物理地址VA，如图7.8，使用CI（后六位再后六 位）进行组索引，每组8路，对8路的块分别匹配 CT（前 40 位）如果匹配成功 且块的valid 标志位为1，则命中（hit），根据数据偏移量CO（后六位）取出数据返回。如果没有匹配成功或者匹配成功但是标志位是1，则不命中（miss），向下一级缓存中查询数据（L2 Cache->L3 Cache->主存）。查询到数据之后，一种简单的放置策略如下：如果映射到的组内有空闲块，则直接放置，否则组内都是有效块，产生冲突（evict），则采用最近最少使用策略LFU进行替换。

 
图7.8 物理内存访问机制

7.6 hello进程fork时的内存映射
当fork函数被shell进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID，为了给这个新进程创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本。它将这两个进程的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。

7.7 hello进程execve时的内存映射
execve函数调用驻留在内核区域的启动加载器代码，在当前进程中加载并运 行包含在可执行目标文件hello中的程序，用hello程序有效地替代了当前程序。 加载并运行hello需要以下几个步骤： 
1.	删除已存在的用户区域，删除当前进程虚拟地址的用户部分中的已存在的区域结构。
2.	映射私有区域，为新程序的代码、数据、bss和栈区域创建新的区域结构，所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为hello文件中的.text和.data区，bss区域是请求二进制零的，映射到匿名文件，其大小包含在 hello 中，栈和堆地址也是请求二进制零的，初始长度为零。 
3.	映射共享区域，hello程序与共享对象libc.so链接，libc.so是动态链接到这个程序中的，然后再映射到用户虚拟地址空间中的共享区域内。
4.	设置程序计数器（PC），execve做的最后一件事情就是设置当前进程上下文的程序计数器，使之指向代码区域的入口点。

 
图7.9 加载器映射用户地址空间区域

7.8 缺页故障与缺页中断处理
缺页故障是一种常见的故障，当指令引用一个虚拟地址，在MMU中查找页表时发现与该地址相对应的物理地址不在内存中，因此必须从磁盘中取出的时候就会发生故障。其处理流程遵循图 7.10 所示的故障处理流程。
缺页中断处理：缺页处理程序是系统内核中的代码，选择一个牺牲页面，如果这个牺牲页面被修改过，那么就将它交换出去，换入新的页面并更新页表。当缺页处理程序返回时，CPU重新启动引起缺页的指令，这条指令再次发送VA到MMU，这次MMU就能正常翻译VA了。

 
图7.10 故障处理流程

7.9动态存储分配管理
printf函数会调用malloc，下面简述动态内存管理的基本方法与策略： 
动态内存分配器维护着一个进程的虚拟内存区域，称为堆。分配器将堆视为 一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，要么是已 分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。  
分配器分为两种基本风格：显式分配器、隐式分配器。  
【显式分配器】要求应用显式地释放任何已分配的块。  
【隐式分配器】要求分配器检测一个已分配块何时不再使用，那么就释放这个块，自动释放未使用的已经分配的块的过程叫做垃圾收集。
1.【带边界标签的隐式空闲链表】
1）堆及堆中内存块的组织结构
 
在内存块中增加4B的Header和4B的Footer，其中Header用于寻找下一个 blcok，Footer用于寻找上一个block。Footer的设计是专门为了合并空闲块方便的。因为Header和Footer大小已知，所以我们利用Header和Footer中存放的块大小就可以寻找上下block。
2）隐式链表
所谓隐式空闲链表，对比于显式空闲链表，代表并不直接对空闲块进行链接，而是将对内存空间中的所有块组织成一个大链表，其中Header和Footer中的block大小间接起到了前驱、后继指针的作用。
3）空闲块合并
因为有了Footer，所以我们可以方便的对前面的空闲块进行合并。合并的情况一共分为四种：前空后不空、前不空后空、前后都空、前后都不空。对于四种情况分别进行空闲块合并，我们只需要通过改变Header和Footer中的值就可以完成这一操作。

2.【显示空间链表基本原理】
将空闲块组织成链表形式的数据结构。堆可以组织成一个双向空闲链表， 在每个空闲块中，都包含一个pred（前驱）和succ（后继）指针，如下图：
 
使用双向链表而不是隐式空闲链表，使首次适配的分配时间从块总数的线性时间减少到了空闲块数量的线性时间。 
维护链表的顺序有：后进先出（LIFO），将新释放的块放置在链表的开始处，使用LIFO的顺序和首次适配的放置策略，分配器会最先检查最近使用过的块，在这种情况下，释放一个块可以在线性的时间内完成，如果使用了边界标记，那么合并也可以在常数时间内完成。按照地址顺序来维护链表，其中链 表中的每个块的地址都小于它的后继的地址，在这种情况下，释放一个块需要线性时间的搜索来定位合适的前驱。平衡点在于，按照地址排序首次适配比 LIFO 排序的首次适配有着更高的内存利用率，接近最佳适配的利用率。
7.10本章小结
本章主要介绍了hello的存储器地址空间、Intel的段式管理、hello的页式管理， 结合hello说明逻辑地址、线性地址、虚拟地址、物理地址的概念等。
特别地，在Intel Core7指定环境下介绍VA到PA的变换、物理内存访问。还介绍了hello进程fork时的内存映射、execve时的内存映射、缺页故障与缺页中断处理以及动态存储分配管理的基本方法和策略。
