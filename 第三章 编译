第3章 编译
3.1 编译的概念与作用
【概念】
编译，是一个过程，该过程调用“编译器”，阅读以某一种语言（源语言）编写的程序，并把该程序翻译成一个等价的、用另一种语言（目标语言）编写的程序。
【作用】
将一种语言编写的程序翻译成另一种等价的语言编写的程序。（这里是将C语言编写的.i文件翻译成AT&T格式的.s文件）
3.2 在Ubuntu下编译的命令
【命令】
Gcc -S hello.i -o hello.s
 
图3.1 生成编译后文件hello.s
3.3 Hello的编译结果解析
3.3.0 汇编指令
指令	含义
.file	声明源文件
.text	代码段
.section/ .rodata	rodata节
.globl	声明一个全局变量
.type	用来指定是函数类型/对象类型
.size	声明大小
.long/ .string	声明一个long/string类型
.align	声明对指令/数据的存放地址进行对齐的方式

3.3.1数据
	hello.s中用到的C数据类型有：字符串、整数和数组，下面依次解析。

3.3.1.1字符串
hello.s程序中的字符串有两个：
1.“Usage:Hello 学号 姓名！\n”，这是第一个printf传入的格式化输出参数，如图。可以发现这个字符串是按照UTF-8格式编码的。（一个汉字在UTF-8编码中占3个字节，而一个\代表一个字节。）
2.“Hello %s %s\n”，这是第二个printf传入的格式化输出参数，如图。
其中后两个字符串都声明在了.rodata只读数据节。

 
图3.2 hello.s文件中的字符串

3.3.1.2整数
程序中涉及的整数有：
1.【int sleepsecs】sleepsecs在C程序中被声明为全局变量，且已经被赋值，编译器处理时在.data节声明该变量，.data节存放已经初始化的全局和静态C变量。在图 3.3 中，可以看到，编译器首先将sleepsecs在.text代码段中声明为全局变量，其次在.data段中，设置对齐方式为4、设置类型为对象、设置大小为 4 字节、设置为long类型且值为2（long类型在linux下与int相同为4B，将int声明为long可能是编译器的怪癖）。

 
图3.3 hello.s文件中整数sleepsecs的相关信息

2.【int i】编译器将局部变量存储在寄存器或者栈空间中，在hello.s中编译器将i存储在栈上空间-4(%rbp)中，可以看出i占据了栈中的4B空间。
3.【int argc】作为第一个参数传入。
4.【立即数】其它整形数据的出现都是以立即数的形式出现的，直接硬编码在汇编代码中。

3.3.1.3数组
程序中涉及数组的是：char *argv[] main，函数执行时输入的命令行， argv 作为存放 char 指针的数组同时是第二个参数传入。 
argv 单个元素 char*大小为 8B，argv 指针指向已经分配好的、一片存 放着字符指针的连续空间，起始地址为 argv，main 函数中访问数组元素 argv[1],argv[2]时，按照起始地址 argv 大小 8B 计算数据地址取数据，在 hello.s 中，使用两次(%rax)（两次 rax 分别为 argv[1]和 argv[2]的地址）取 出其值，如下图：

 
图3.4 获取数组值（通过计算地址）

3.3.2赋值
程序中涉及的赋值操作有：
1.【int sleepsecs=2.5】因为sleepsecs是全局变量，所以直接在.data节中将sleepsecs声明为值2的long类型数据。
2.【i=0】整形数据的赋值使用mov指令完成，根据数据大小的不同，采用不同的后缀（详见表）。因为i是4B大小的int型，所以使用的操作室movl。

表3.1 mov指令后缀含义
后缀	b	w	l	Q
操作数大小	1B	2B	4B	8B

 
图3.5 hello.s文件中变量i的赋值语句

3.3.3类型转换
程序中涉及“隐式”类型转换的是：int sleepsecs=2.5，将浮点数类型的2.5转换为int类型。 
当在double或float向int进行类型转换的时候，程序改变数值和位模式的原则是：向零舍入。例如1.789 将被转换成1而-1.789 将被转换成-1。进一步来讲，可能会产生值溢出的情况，与Intel兼容的微处理器指定位模式[10…000]为整数不确定值，一个浮点数到整数的转换，如果不能为该浮点数找到一个合适的整数近似值，就会产生一个整数不确定值。 
浮点数默认类型为double，所以上述强制转化是double强制转化为int类型。 遵从向零舍入的原则，将2.5舍入为2。

3.3.4算数操作
程序中涉及的算数操作有：
1.【i++】对计数器i自增，使用程序指令addl，后缀l代表操作数是一个4B大小的数据。
2.【leaq .LC1(%rip),%rdi】汇编中使用 leaq .LC1(%rip),%rdi，使用了加载有效地址指令leaq计算LC1的段地址%rip+.LC1并传递给%rdi。

表3.2 汇编指令（用于数据算数操作）
指令	作用
Leaq S,D	D=&S
INC D	D=D+1
DEC D	D=D-1
NEG D	D=-D
ADD S,D	D=D+S
SUB S,D	D=D-S
IMULQ S	R[%rdx]:R[%rax]=S*R[%rax]（有符号）
MULQ S	R[%rdx]:R[%rax]=S*R[%rax]（无符号）
IDIVQ S	R[%rdx]=R[%rdx]:R[%rax]mod S（有符号）
R[%rax]=R[%rdx]:R[%rax]div S
DIVQ S	R[%rdx]=R[%rdx]:R[%rax]mod S（无符号）
R[%rax]=R[%rdx]:R[%rax]div S

3.3.5关系操作
程序中涉及的关系操作有：
1.【argc!=3】判断argc是否等于3。hello.s 中使用 cmpl $3,-20(%rbp)，计算argc-3然后设置条件码，为下一步je利用条件码进行跳转作准备。
2.【i<10】判断i是否小于10。hello.s 中使用 cmpl $9,-4(%rbp)，计算 i-9 然后设置条件码，为下一步jle利用条件码进行跳转做准备。

表3.3 汇编指令（用于关系操作）
指令	作用	描述
CMP S1,S2	S2-S1	比较、设置条件码
TEST S1,S2	S1&S2	测试、设置条件码
SETxx D	D=xx	条件设置
Jxx	--	条件跳转

3.3.6控制转移
程序中涉及的控制转移有：
1.【if(argv!=3)】当argv不等于3的时候执行程序段中的代码。如图 3.6，对于if判断，编译器使用条件跳转指令实现，首先cmpl比较argv和3，设置条件码，使用je判断ZF标志位，如果为0，说明argv-3=0即argv==3，则不执行if中的代码直接跳转到.L2，否则顺序执行下一条语句即执行if中的代码。

 
图3.6 hello.s文件中的if汇编代码块

2.【for(i=0;i<10;i++)】使用计数变量i循环10次。如图 3.7，编译器的编译逻辑是，首先无条件跳转到位于循环体.L4 之后的比较代码，使用cmpl进行比较，如果i<=9，则跳入.L4 for 循环体执行，否则说明循环结束，顺序执行for之后的逻辑。

 
图3.7 hello.s文件中的for汇编代码块

3.3.7函数操作
函数是一种过程，过程提供了一种封装代码的方式，用一组指定的参数和可选 的返回值实现某种功能。A中调用函数B包含以下动作：
1.传递控制：进行过程B的时候，程序计数器必须设置为B的代码的起始地址，然后在返回时，要把程序计数器设置为A中调用B后面那条指令的地址。
2.传递数据：A必须能够向B提供一个或多个参数，B必须能够向A中返回一个值。
3.分配和释放内存：在开始时，B可能需要为局部变量分配空间，而在返回前，又必须释放这些空间。

表3.4 64位程序参数存储顺序（不包括浮点数）
1	2	3	4	5	6	7
%rdi	%rsi	%rdx	%rcx	%r8	%r9	栈

程序中涉及的函数操作有：
1.【main函数】
①传递控制。main 函数因为被调用 call 才能执行（被系统启动函数 __libc_start_main 调用），call 指令将下一条指令的地址 dest 压栈，然后跳转到 main 函数。 
②传递数据。外部调用过程向 main 函数传递参数 argc 和 argv，分别 使用%rdi 和%rsi 存储，函数正常出口为 return 0，将%eax 设置 0 返回。 
③分配和释放内存。使用%rbp 记录栈帧的底，函数分配栈帧空间 在%rbp 之上，程序结束时，调用 leave 指令，leave 相当于 mov %rbp,%rsp,pop %rbp，恢复栈空间为调用之前的状态，然后 ret 返回，ret 相当 pop IP，将下一条要执行指令的地址设置为 dest。
2.【printf函数】
①传递数据。第一次 printf 将%rdi 设置为“Usage: Hello 学号 姓名！ \n”字符串的首地址。第二次 printf 设置%rdi 为“Hello %s %s\n” 的首地址，设置%rsi 为 argv[1]，%rdx 为 argv[2]。 
②控制传递。第一次 printf 因为只有一个字符串参数，所以 call puts@PLT；第二次 printf 使用 call printf@PLT。
3.【exit函数】
①传递数据。将%edi设置为1。 
②控制传递。call exit@PLT。
4.【sleep函数】
①传递数据。将%edi设置为sleepsecs。 
②控制传递。call sleep@PLT。
5.【getchar函数】
①控制传递。call gethcar@PLT。

3.4 本章小结
本章主要介绍了编译的概念、作用、在ubuntu下的命令。重点阐述了hello.s汇编文件的各个数据类型和各类操作。
在数据类型中，我们详细看了hello.s中的字符串、整数和数组。在各类操作中，我们重点考察了诸如类型转换、算数操作、关系操作、控制转移和函数操作等。这对于我们理解更复杂的程序具有重要的指导意义。
当编译器将.i文件翻译为.s汇编代码之后，hello变成了更加低级的、更靠近机器语言的程序。
