第6章 hello进程管理
6.1 进程的概念与作用
【概念】
进程是一个执行中的程序的实例。
每一个进程都有它自己的地址空间，一般情况下，包括文本区域、数据区域、和堆栈。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。
【作用】
进程为用户提供了以下假象（抽象概念）：
1.	我们的程序好像是系统中当前运行的唯一程序。
2.	我们的程序好像是独占的使用处理器和内存，处理器好像是无间断的执行 我们程序中的指令。
3.	我们程序中的代码和数据好像是系统内存中唯一的对象。

6.2 简述壳Shell-bash的作用与处理流程
【作用】
Shell是一个用C语言编写的程序，他是用户使用Linux的桥梁。
Shell是一种应用程序，该应用程序提供了一个界面，用户通过这个界面访问操作系统内核提供的服务。
【处理流程】
1.	从终端读入输入的命令。
2.	将输入字符串切分获得所有的参数。 
3.	如果是内置命令则立即执行。 
4.	否则调用相应的程序为其分配子进程并运行。 
5.	shell 应该接受键盘输入信号，并对这些信号进行相应处理。

6.3 Hello的fork进程创建过程
在终端中键入./hello H170301801 YuanKang，运行的终端程序会对输入的命令行进行解析。
因为hello不是一个内置的shell命令，所以解析之后终端程序判断./hello的语义为执行当前目录下的可执行目标文件hello。
之后终端程序首先会调用fork函数创建一个新的运行的子进程，新创建的子进程几乎但不完全与父进程相同，子进程得到与父进程用户级虚拟地址空间相同的（但是独立的）一份副本，这就意味着，当父进程调用 fork 时，子进程可以读写父进程中打开的任何文件。
父进程与子进程之间最大的区别在于它们拥有不同的PID。父进程与子进程是并发运行的独立进程，内核能够以任意方式交替执行它们的逻辑控制流的指令。在子进程执行期间，父进程默认选项是显示等待子进程的完成。
进程示意图如下：

 
图6.1 终端程序的进程示意图

6.4 Hello的execve过程
当fork之后，子进程调用execve函数（传入命令行参数）在当前进程的上下 文中加载并运行一个新程序即hello程序。
execve调用驻留在内存中的被称为启动加载器的操作系统代码来执行hello程序。加载器删除子进程现有的虚拟内存段，并创建一组新的代码、数据、堆和栈段。新的栈和堆段被初始化为零，通过将虚拟地址空间中的页映射到可执行文件的页大小的片，新的代码和数据段被初始化为可执行文件中的内容。
最后加载器设置PC指向_start 地址，_start 最终调用hello中的main函数。除了一些头部信息，在加载过程中没有任何从磁盘到内存的数据复制。直到CPU引用一个被映射的虚拟页时才会进行复制，这时，操作系统利用它的页面调度机制自动将页面从磁盘传送到内存。
加载器创建的内存映像如下：

 
图6.2 加载器创建的内存映像

6.5 Hello的进程执行
	常用概念：
【逻辑控制流】一系列程序计数器PC的值的序列叫做逻辑控制流。进程是轮流使用处理器的，在同一个处理器核心中，每个进程执行它的流的一部分后被抢占（暂时挂起），然后轮到其他进程。  
【时间片】一个进程执行它的控制流的一部分的每一个小时间段叫做时间片。  
【用户模式和内核模式】处理器通常使用一个寄存器提供两种模式的区分，该寄存器描述了进程当前享有的特权。当没有设置模式位时，进程就处于用户模式中，用户模式的进程不允许执行特权指令，也不允许直接引用地址空间中内核区内的代码和数据；设置模式位时，进程处于内核模式，该进程可以执行指令集中的任何命令，并且可以访问系统中的任何内存位置。  
【上下文信息】上下文就是内核重新启动一个被抢占的进程所需要的状态，它由通用寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构等对象的值构成。

	分析hello sleep的进程执行：
	当调用sleep之前，如果hello程序不被抢占则顺序执行，假如发生被抢占的情况，则进行上下文切换。上下文切换是由内核中调度器完成的，当内核调度新的进程运行后，它就会抢占当前进程，并进行1）保存以前进程的上下文；2）恢复新恢复进程被保存的上下文；3）将控制传递给这个新恢复的进程，来完成上下文切换。
如图6.3，hello初始运行在用户模式，在hello进程调用sleep之后陷入内核模 式，内核处理休眠请求主动释放当前进程，并将hello进程从运行队列中移出加入 等待队列，定时器开始计时，内核进行上下文切换将当前进程的控制权交给其他 进程。
当定时器到时时（2.5secs）发送一个中断信号，此时进入内核状态执行中断 处理，将hello进程从等待队列中移出重新加入到运行队列，成为就绪状态，hello进程就可以继续进行自己的控制逻辑流了。

 
图6.3 hello sleep进程的上下文切换示意图

	此外，当hello调用getchar的时候，实际上执行的输入流是stdin的系统调用read。
hello之前运行在用户模式，在进行read调用之后陷入内核，内核中的陷阱处理程序请求来自键盘缓冲区的DMA传输，并且安排在完成从键盘缓冲区到内存的数据传输后，中断处理器。
此时进入内核模式，内核执行上下文切换，切换到其他进程。当完成键盘缓冲区到内存的数据传输时，引发一个中断信号，此时内核从其他进程进行上下文切换回到hello进程。

6.6 hello的异常与信号处理
如图6.4（a），是正常执行hello程序的结果，当程序执行完成之后，进程被回收。  
如图6.4（b），是在程序输出2条info之后按下Ctrl-Z的结果，当按下Ctrl-Z之后，shell父进程收到SIGSTP信号，信号处理函数的逻辑是打印屏幕回显、将hello进程挂起，通过ps命令我们可以看出hello进程没有被回收，此时他的后台job号是1，调用fg 1将其调到前台，此时shell程序首先打印hello的命令行命令，hello继续运行打印剩下的8条info，之后按下回车，程序结束，同时进程被回收。
如图 6.4（c）是在程序输出3条info之后按下Ctrl-C的结果，当按下Ctrl-C之后，shell父进程收到SIGINT信号，信号处理函数的逻辑是结束hello，并回收hello进程。  
如图 6.4（d）是在程序运行中输入任意字符的结果，可以发现，程序只是将屏幕的输入缓存到stdin，当getchar的时候读出一个’\n’结尾的字串（作为一次输入），其他字串会当做shell命令行输入。
 
 
图6.4（a） 正常运行hello程序

 
图6.4（b） hello运行中按下Ctrl-Z

 
图6.4（c） hello运行中按下Ctrl-C

 
图6.4（d）hello运行中输如任意字符

6.7本章小结
在本章中，我们简单介绍了进程的概念、作用和shell的处理流程。结合进程上下文信息、进程时间片，阐述了进程调度的过程，用户态与核心态转换等。
其中，重点考察了hello程序运行时候的进程执行、异常和信号处理。这对于理解、分析其它复杂进程具有重要的指导意义。
